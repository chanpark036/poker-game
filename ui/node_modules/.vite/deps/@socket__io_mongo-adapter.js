import {
  require_lib
} from "./chunk-UQUL26EU.js";
import {
  require_dist
} from "./chunk-6WN5BPKW.js";
import {
  require_crypto
} from "./chunk-R6WDS35Z.js";
import {
  __commonJS
} from "./chunk-GFT2G5UO.js";

// ../server/node_modules/@socket.io/mongo-adapter/node_modules/ms/index.js
var require_ms = __commonJS({
  "../server/node_modules/@socket.io/mongo-adapter/node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../server/node_modules/@socket.io/mongo-adapter/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../server/node_modules/@socket.io/mongo-adapter/node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../server/node_modules/@socket.io/mongo-adapter/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../server/node_modules/@socket.io/mongo-adapter/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../server/node_modules/@socket.io/mongo-adapter/dist/index.js
var require_dist2 = __commonJS({
  "../server/node_modules/@socket.io/mongo-adapter/dist/index.js"(exports) {
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoAdapter = exports.createAdapter = void 0;
    var socket_io_adapter_1 = require_dist();
    var crypto_1 = require_crypto();
    var mongodb_1 = require_lib();
    var randomId = () => (0, crypto_1.randomBytes)(8).toString("hex");
    var debug = require_browser()("socket.io-mongo-adapter");
    var EventType;
    (function(EventType2) {
      EventType2[EventType2["INITIAL_HEARTBEAT"] = 1] = "INITIAL_HEARTBEAT";
      EventType2[EventType2["HEARTBEAT"] = 2] = "HEARTBEAT";
      EventType2[EventType2["BROADCAST"] = 3] = "BROADCAST";
      EventType2[EventType2["SOCKETS_JOIN"] = 4] = "SOCKETS_JOIN";
      EventType2[EventType2["SOCKETS_LEAVE"] = 5] = "SOCKETS_LEAVE";
      EventType2[EventType2["DISCONNECT_SOCKETS"] = 6] = "DISCONNECT_SOCKETS";
      EventType2[EventType2["FETCH_SOCKETS"] = 7] = "FETCH_SOCKETS";
      EventType2[EventType2["FETCH_SOCKETS_RESPONSE"] = 8] = "FETCH_SOCKETS_RESPONSE";
      EventType2[EventType2["SERVER_SIDE_EMIT"] = 9] = "SERVER_SIDE_EMIT";
      EventType2[EventType2["SERVER_SIDE_EMIT_RESPONSE"] = 10] = "SERVER_SIDE_EMIT_RESPONSE";
      EventType2[EventType2["BROADCAST_CLIENT_COUNT"] = 11] = "BROADCAST_CLIENT_COUNT";
      EventType2[EventType2["BROADCAST_ACK"] = 12] = "BROADCAST_ACK";
      EventType2[EventType2["SESSION"] = 13] = "SESSION";
    })(EventType || (EventType = {}));
    var EMITTER_UID = "emitter";
    var replaceBinaryObjectsByBuffers = (obj) => {
      if (!obj || typeof obj !== "object") {
        return obj;
      }
      if (obj._bsontype === "Binary" && Buffer.isBuffer(obj.buffer)) {
        return obj.buffer;
      }
      if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
          obj[i] = replaceBinaryObjectsByBuffers(obj[i]);
        }
      } else {
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            obj[key] = replaceBinaryObjectsByBuffers(obj[key]);
          }
        }
      }
      return obj;
    };
    function onPublishError(err) {
      debug("something went wrong when inserting the MongoDB document: %s", err);
    }
    function createAdapter(mongoCollection, opts = {}) {
      opts.uid = opts.uid || randomId();
      let isClosed = false;
      let adapters = /* @__PURE__ */ new Map();
      let changeStream;
      let changeStreamOpts = {};
      const initChangeStream = () => {
        if (isClosed || changeStream && !changeStream.closed) {
          return;
        }
        debug("opening change stream");
        changeStream = mongoCollection.watch([
          {
            $match: {
              "fullDocument.uid": {
                $ne: opts.uid
                // ignore events from self
              }
            }
          }
        ], changeStreamOpts);
        changeStream.on("change", (event) => {
          var _a, _b;
          if (event.operationType === "insert") {
            changeStreamOpts.resumeAfter = changeStream.resumeToken;
            (_b = adapters.get((_a = event.fullDocument) === null || _a === void 0 ? void 0 : _a.nsp)) === null || _b === void 0 ? void 0 : _b.onEvent(event);
          }
        });
        changeStream.on("error", (err) => {
          debug("change stream encountered an error: %s", err.message);
          if (err instanceof mongodb_1.MongoServerError && !err.hasErrorLabel("ResumableChangeStreamError")) {
            changeStreamOpts = {};
          }
        });
        changeStream.on("close", () => {
          debug("change stream was closed, scheduling reconnection...");
          setTimeout(() => {
            initChangeStream();
          }, 1e3);
        });
      };
      return function(nsp) {
        if (!changeStream) {
          isClosed = false;
          initChangeStream();
        }
        let adapter = new MongoAdapter(nsp, mongoCollection, opts);
        adapters.set(nsp.name, adapter);
        const defaultClose = adapter.close;
        adapter.close = async () => {
          adapters.delete(nsp.name);
          if (adapters.size === 0) {
            changeStream.removeAllListeners("close");
            await changeStream.close();
            changeStream = null;
            isClosed = true;
          }
          defaultClose.call(adapter);
        };
        return adapter;
      };
    }
    exports.createAdapter = createAdapter;
    var MongoAdapter = class _MongoAdapter extends socket_io_adapter_1.Adapter {
      /**
       * Adapter constructor.
       *
       * @param nsp - the namespace
       * @param mongoCollection - a MongoDB collection instance
       * @param opts - additional options
       *
       * @public
       */
      constructor(nsp, mongoCollection, opts = {}) {
        super(nsp);
        this.nodesMap = /* @__PURE__ */ new Map();
        this.requests = /* @__PURE__ */ new Map();
        this.ackRequests = /* @__PURE__ */ new Map();
        this.isClosed = false;
        this.mongoCollection = mongoCollection;
        this.uid = opts.uid;
        this.requestsTimeout = opts.requestsTimeout || 5e3;
        this.heartbeatInterval = opts.heartbeatInterval || 5e3;
        this.heartbeatTimeout = opts.heartbeatTimeout || 1e4;
        this.addCreatedAtField = !!opts.addCreatedAtField;
        this.publish({
          type: EventType.INITIAL_HEARTBEAT
        }).catch(onPublishError);
      }
      close() {
        this.isClosed = true;
        if (this.heartbeatTimer) {
          clearTimeout(this.heartbeatTimer);
        }
        return;
      }
      async onEvent(event) {
        const document2 = event.fullDocument;
        debug("new event of type %d for %s from %s", document2.type, document2.nsp, document2.uid);
        if (document2.uid && document2.uid !== EMITTER_UID) {
          this.nodesMap.set(document2.uid, Date.now());
        }
        switch (document2.type) {
          case EventType.INITIAL_HEARTBEAT: {
            this.publish({
              type: EventType.HEARTBEAT
            }).catch(onPublishError);
            break;
          }
          case EventType.BROADCAST: {
            debug("broadcast with opts %j", document2.data.opts);
            const withAck = document2.data.requestId !== void 0;
            if (withAck) {
              super.broadcastWithAck(replaceBinaryObjectsByBuffers(document2.data.packet), _MongoAdapter.deserializeOptions(document2.data.opts), (clientCount) => {
                debug("waiting for %d client acknowledgements", clientCount);
                this.publish({
                  type: EventType.BROADCAST_CLIENT_COUNT,
                  data: {
                    requestId: document2.data.requestId,
                    clientCount
                  }
                });
              }, (arg) => {
                debug("received acknowledgement with value %j", arg);
                this.publish({
                  type: EventType.BROADCAST_ACK,
                  data: {
                    requestId: document2.data.requestId,
                    packet: arg
                  }
                });
              });
            } else {
              const packet = replaceBinaryObjectsByBuffers(document2.data.packet);
              const opts = _MongoAdapter.deserializeOptions(document2.data.opts);
              this.addOffsetIfNecessary(packet, opts, document2._id);
              super.broadcast(packet, opts);
            }
            break;
          }
          case EventType.BROADCAST_CLIENT_COUNT: {
            const request = this.ackRequests.get(document2.data.requestId);
            request === null || request === void 0 ? void 0 : request.clientCountCallback(document2.data.clientCount);
            break;
          }
          case EventType.BROADCAST_ACK: {
            const request = this.ackRequests.get(document2.data.requestId);
            const clientResponse = replaceBinaryObjectsByBuffers(document2.data.packet);
            request === null || request === void 0 ? void 0 : request.ack(clientResponse);
            break;
          }
          case EventType.SOCKETS_JOIN: {
            debug("calling addSockets with opts %j", document2.data.opts);
            super.addSockets(_MongoAdapter.deserializeOptions(document2.data.opts), document2.data.rooms);
            break;
          }
          case EventType.SOCKETS_LEAVE: {
            debug("calling delSockets with opts %j", document2.data.opts);
            super.delSockets(_MongoAdapter.deserializeOptions(document2.data.opts), document2.data.rooms);
            break;
          }
          case EventType.DISCONNECT_SOCKETS: {
            debug("calling disconnectSockets with opts %j", document2.data.opts);
            super.disconnectSockets(_MongoAdapter.deserializeOptions(document2.data.opts), document2.data.close);
            break;
          }
          case EventType.FETCH_SOCKETS: {
            debug("calling fetchSockets with opts %j", document2.data.opts);
            const localSockets = await super.fetchSockets(_MongoAdapter.deserializeOptions(document2.data.opts));
            this.publish({
              type: EventType.FETCH_SOCKETS_RESPONSE,
              data: {
                requestId: document2.data.requestId,
                sockets: localSockets.map((socket) => ({
                  id: socket.id,
                  handshake: socket.handshake,
                  rooms: [...socket.rooms],
                  data: socket.data
                }))
              }
            }).catch(onPublishError);
            break;
          }
          case EventType.FETCH_SOCKETS_RESPONSE: {
            const request = this.requests.get(document2.data.requestId);
            if (!request) {
              return;
            }
            request.current++;
            document2.data.sockets.forEach((socket) => request.responses.push(socket));
            if (request.current === request.expected) {
              clearTimeout(request.timeout);
              request.resolve(request.responses);
              this.requests.delete(document2.data.requestId);
            }
            break;
          }
          case EventType.SERVER_SIDE_EMIT: {
            const packet = document2.data.packet;
            const withAck = document2.data.requestId !== void 0;
            if (!withAck) {
              this.nsp._onServerSideEmit(packet);
              return;
            }
            let called = false;
            const callback = (arg) => {
              if (called) {
                return;
              }
              called = true;
              debug("calling acknowledgement with %j", arg);
              this.publish({
                type: EventType.SERVER_SIDE_EMIT_RESPONSE,
                data: {
                  requestId: document2.data.requestId,
                  packet: arg
                }
              });
            };
            packet.push(callback);
            this.nsp._onServerSideEmit(packet);
            break;
          }
          case EventType.SERVER_SIDE_EMIT_RESPONSE: {
            const request = this.requests.get(document2.data.requestId);
            if (!request) {
              return;
            }
            request.current++;
            request.responses.push(document2.data.packet);
            if (request.current === request.expected) {
              clearTimeout(request.timeout);
              request.resolve(null, request.responses);
              this.requests.delete(document2.data.requestId);
            }
          }
        }
      }
      scheduleHeartbeat() {
        if (this.heartbeatTimer) {
          clearTimeout(this.heartbeatTimer);
        }
        this.heartbeatTimer = setTimeout(() => {
          debug("sending heartbeat");
          this.publish({
            type: EventType.HEARTBEAT
          }).catch(onPublishError);
          this.scheduleHeartbeat();
        }, this.heartbeatInterval);
      }
      publish(document2) {
        if (this.isClosed) {
          return Promise.reject("adapter is closed");
        }
        debug("publish document %d", document2.type);
        document2.uid = this.uid;
        document2.nsp = this.nsp.name;
        if (this.addCreatedAtField) {
          document2.createdAt = /* @__PURE__ */ new Date();
        }
        this.scheduleHeartbeat();
        return this.mongoCollection.insertOne(document2).then((result) => result.insertedId.toString("hex"));
      }
      /**
       * Transform ES6 Set into plain arrays
       */
      static serializeOptions(opts) {
        return {
          rooms: [...opts.rooms],
          except: opts.except ? [...opts.except] : [],
          flags: opts.flags
        };
      }
      static deserializeOptions(opts) {
        return {
          rooms: new Set(opts.rooms),
          except: new Set(opts.except),
          flags: opts.flags
        };
      }
      async broadcast(packet, opts) {
        var _a;
        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (!onlyLocal) {
          try {
            const offset = await this.publish({
              type: EventType.BROADCAST,
              data: {
                packet,
                opts: _MongoAdapter.serializeOptions(opts)
              }
            });
            this.addOffsetIfNecessary(packet, opts, offset);
          } catch (err) {
            debug("error while inserting document: %s", err);
            return;
          }
        }
        process.nextTick(() => {
          super.broadcast(packet, opts);
        });
      }
      /**
       * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it
       * reconnects after a temporary disconnection.
       *
       * @param packet
       * @param opts
       * @param offset
       * @private
       */
      addOffsetIfNecessary(packet, opts, offset) {
        var _a;
        if (!this.nsp.server.opts.connectionStateRecovery) {
          return;
        }
        const isEventPacket = packet.type === 2;
        const withoutAcknowledgement = packet.id === void 0;
        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === void 0;
        if (isEventPacket && withoutAcknowledgement && notVolatile) {
          packet.data.push(offset);
        }
      }
      broadcastWithAck(packet, opts, clientCountCallback, ack) {
        var _a;
        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (!onlyLocal) {
          const requestId = randomId();
          this.publish({
            type: EventType.BROADCAST,
            data: {
              packet,
              requestId,
              opts: _MongoAdapter.serializeOptions(opts)
            }
          }).catch(onPublishError);
          this.ackRequests.set(requestId, {
            type: EventType.BROADCAST,
            clientCountCallback,
            ack
          });
          setTimeout(() => {
            this.ackRequests.delete(requestId);
          }, opts.flags.timeout);
        }
        process.nextTick(() => {
          super.broadcastWithAck(packet, opts, clientCountCallback, ack);
        });
      }
      serverCount() {
        this.nodesMap.forEach((lastSeen, uid) => {
          const nodeSeemsDown = Date.now() - lastSeen > this.heartbeatTimeout;
          if (nodeSeemsDown) {
            debug("node %s seems down", uid);
            this.nodesMap.delete(uid);
          }
        });
        return Promise.resolve(1 + this.nodesMap.size);
      }
      addSockets(opts, rooms) {
        var _a;
        super.addSockets(opts, rooms);
        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (onlyLocal) {
          return;
        }
        this.publish({
          type: EventType.SOCKETS_JOIN,
          data: {
            opts: _MongoAdapter.serializeOptions(opts),
            rooms
          }
        }).catch(onPublishError);
      }
      delSockets(opts, rooms) {
        var _a;
        super.delSockets(opts, rooms);
        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (onlyLocal) {
          return;
        }
        this.publish({
          type: EventType.SOCKETS_LEAVE,
          data: {
            opts: _MongoAdapter.serializeOptions(opts),
            rooms
          }
        }).catch(onPublishError);
      }
      disconnectSockets(opts, close) {
        var _a;
        super.disconnectSockets(opts, close);
        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (onlyLocal) {
          return;
        }
        this.publish({
          type: EventType.DISCONNECT_SOCKETS,
          data: {
            opts: _MongoAdapter.serializeOptions(opts),
            close
          }
        }).catch(onPublishError);
      }
      async fetchSockets(opts) {
        var _a;
        const localSockets = await super.fetchSockets(opts);
        const expectedResponseCount = await this.serverCount() - 1;
        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount === 0) {
          return localSockets;
        }
        const requestId = randomId();
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            const storedRequest2 = this.requests.get(requestId);
            if (storedRequest2) {
              reject(new Error(`timeout reached: only ${storedRequest2.current} responses received out of ${storedRequest2.expected}`));
              this.requests.delete(requestId);
            }
          }, this.requestsTimeout);
          const storedRequest = {
            type: EventType.FETCH_SOCKETS,
            resolve,
            timeout,
            current: 0,
            expected: expectedResponseCount,
            responses: localSockets
          };
          this.requests.set(requestId, storedRequest);
          this.publish({
            type: EventType.FETCH_SOCKETS,
            data: {
              opts: _MongoAdapter.serializeOptions(opts),
              requestId
            }
          });
        });
      }
      serverSideEmit(packet) {
        const withAck = typeof packet[packet.length - 1] === "function";
        if (withAck) {
          this.serverSideEmitWithAck(packet).catch(() => {
          });
          return;
        }
        this.publish({
          type: EventType.SERVER_SIDE_EMIT,
          data: {
            packet
          }
        }).catch(onPublishError);
      }
      async serverSideEmitWithAck(packet) {
        const ack = packet.pop();
        const expectedResponseCount = await this.serverCount() - 1;
        debug('waiting for %d responses to "serverSideEmit" request', expectedResponseCount);
        if (expectedResponseCount <= 0) {
          return ack(null, []);
        }
        const requestId = randomId();
        const timeout = setTimeout(() => {
          const storedRequest2 = this.requests.get(requestId);
          if (storedRequest2) {
            ack(new Error(`timeout reached: only ${storedRequest2.current} responses received out of ${storedRequest2.expected}`), storedRequest2.responses);
            this.requests.delete(requestId);
          }
        }, this.requestsTimeout);
        const storedRequest = {
          type: EventType.FETCH_SOCKETS,
          resolve: ack,
          timeout,
          current: 0,
          expected: expectedResponseCount,
          responses: []
        };
        this.requests.set(requestId, storedRequest);
        this.publish({
          type: EventType.SERVER_SIDE_EMIT,
          data: {
            requestId,
            packet
          }
        }).catch(onPublishError);
      }
      persistSession(session) {
        debug("persisting session: %j", session);
        this.publish({
          type: EventType.SESSION,
          data: session
        }).catch(onPublishError);
      }
      async restoreSession(pid, offset) {
        var _a, e_1, _b, _c;
        var _d, _e;
        if (!mongodb_1.ObjectId.isValid(offset)) {
          return Promise.reject("invalid offset");
        }
        debug("restoring session: %s", pid);
        const eventOffset = new mongodb_1.ObjectId(offset);
        let results;
        try {
          results = await Promise.all([
            // could use a sparse index on [data.pid] (only index the documents whose type is EventType.SESSION)
            this.findSession(pid),
            this.mongoCollection.findOne({
              type: EventType.BROADCAST,
              _id: eventOffset
            })
          ]);
        } catch (e) {
          debug("error while fetching session: %s", e.message);
          return Promise.reject("error while fetching session");
        }
        if (!results[0] || !results[1]) {
          return Promise.reject("session or offset not found");
        }
        const session = results[0].data;
        const cursor = this.mongoCollection.find({
          $and: [
            {
              type: EventType.BROADCAST
            },
            {
              _id: {
                $gt: eventOffset
              }
            },
            {
              nsp: this.nsp.name
            },
            {
              $or: [
                {
                  "data.opts.rooms": {
                    $size: 0
                  }
                },
                {
                  "data.opts.rooms": {
                    $in: session.rooms
                  }
                }
              ]
            },
            {
              $or: [
                {
                  "data.opts.except": {
                    $size: 0
                  }
                },
                {
                  "data.opts.except": {
                    $nin: session.rooms
                  }
                }
              ]
            }
          ]
        });
        session.missedPackets = [];
        try {
          try {
            for (var _f = true, cursor_1 = __asyncValues(cursor), cursor_1_1; cursor_1_1 = await cursor_1.next(), _a = cursor_1_1.done, !_a; ) {
              _c = cursor_1_1.value;
              _f = false;
              try {
                const document2 = _c;
                const packetData = (_e = (_d = document2 === null || document2 === void 0 ? void 0 : document2.data) === null || _d === void 0 ? void 0 : _d.packet) === null || _e === void 0 ? void 0 : _e.data;
                if (packetData) {
                  session.missedPackets.push(packetData);
                }
              } finally {
                _f = true;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_f && !_a && (_b = cursor_1.return))
                await _b.call(cursor_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } catch (e) {
          return Promise.reject("error while fetching missed packets");
        }
        return session;
      }
      findSession(pid) {
        const isCollectionCapped = !this.addCreatedAtField;
        if (isCollectionCapped) {
          return this.mongoCollection.findOne({
            type: EventType.SESSION,
            "data.pid": pid
          }, {
            sort: {
              _id: -1
            }
          }).then((result) => {
            if (!result) {
              debug("session not found");
              return;
            }
            if (result.data.sid) {
              debug("session found, adding tombstone");
              const TOMBSTONE_SESSION = { pid, tombstone: true };
              this.persistSession(TOMBSTONE_SESSION);
              return result;
            } else {
              debug("tombstone session found");
            }
          });
        } else {
          return this.mongoCollection.findOneAndDelete({
            type: EventType.SESSION,
            "data.pid": pid
          }).then((result) => {
            return (result === null || result === void 0 ? void 0 : result.ok) && result.value ? result.value : result;
          });
        }
      }
    };
    exports.MongoAdapter = MongoAdapter;
  }
});
export default require_dist2();
//# sourceMappingURL=@socket__io_mongo-adapter.js.map
